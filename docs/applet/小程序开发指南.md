# 小程序开发指南

## 小程序开发环境及起步

- 使用浏览器打开 [申请APPId](https://mp.weixin.qq.com/) 点击立即注册，如图1-1所示，在打开的页面中选择小程序后，填入相关的信息，就可以完成注册了。
- 安装开发者工具，[软件地址](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)
  
## 小程序代码构成

### 一.wxml 后缀的WXML模板文件

- 相当于网页中的HTML，WXML 由标签、属性等等构成。
- WXML要求标签必须是严格闭合的，没有闭合将会导致编译错误。
- WXML中的属性是大小写敏感的

```HTML
<view class="container">
  <view class="userinfo">
    <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>
    <block wx:else>
      <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>
      <text class="userinfo-nickname">{{userInfo.nickName}}</text>
    </block>
  </view>
  <view class="usermotto">
    <text class="user-motto">{{motto}}</text>
  </view>
</view>
```

**HTML与WXML的区别**

  - 标签名不一样
      > 小程序的WXML用的标签是 view,button,text等。还提供了地图、视频、音频等组件能力
  - 多了一些wx:if这样的属性及{{}}的表达式
      > 在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。

<img :src="$withBase('/mvvm.png')" />

小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。

**WXML 是这么写 :**
```HTML
<text>{{text}}</text>
```
JS 只需要管理状态即可:
```JS
this.setData({ msg: "Hello World" })
```
> 通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。

#### 数据绑定

- WXML通过{{变量名}}来绑定WXML文件和对应的JavaScript文件中的data对象属性。
- 属性值必须被包裹再双引号中。
- 变量名是大小写敏感的。即{{name}}和{{Name}}是两个不同的变量
- 没有被定义的变量或者是被设置为undefined的变量是不会被同步到wxml中

#### 逻辑语法

- 通过{{ 变量名 }}语法可以使WXML拥有动态渲染的能力，还可以在{{}}内进行简单的逻辑运算
```JS
//三元运算
// 根据a的值是否等于10 在页面输出不同的内容
<text>{{ a===10?"变量a等于10": "变量a不等于10" }}</text>


// 算数运算
// {a:1, b:2, c:3}

<view> {{a+b}} + {{c}} + d </view> //3+3+d


//还支持字符串的拼接
// {name: 'world'}

<view>{{ "hello" + name }}</view> //输出hello world

// 还可以放置数字、字符串或者数组

<text>{{1,2,3}}</text> //输出1，2，3

<text>{{"hello world"}}</text> //输出hello world

```
#### 条件逻辑

- WXML中，使用wx:if = "{{condition}}"来判断是否需要渲染该代码块
```
<view wx:if="{{length > 5}}">1</view>
<view wx:elif="{{length > 2}}">2</view>
<view wx:else>3</view>

```
- 因为wx:if是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个<block />标签，将多个组件包装起来，并在上面使用wx:if控制属性
```
<block wx:if="{{true}}">
    <view>view1</view>
    <view>view2</view>
</block>
```
#### 列表渲染

- 在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。
- 默认数组的当前项的下标变量名默认为index,数组当前项的变量名默认为item

```js
// array是一个数组
<view wx:for="{{array}}">
    {{index}}:{{item.message}}
</view>


// 对应的脚本文件
Page({
    data:{
        array:[{
            message: 'foo',
        },{
            message:'bar'
        }]
    }
})


//使用wx:for-item指定数组当前元素的变量名，使用wx:for-index指定数组当前下标的变量名
<view wx:for="{{array}}" wx:for-index = "idx" wx:for-item="itemName">
    {{idx}}:{{itemName.message}}
</view>

//类似block:if，也可以将wx:for用在<block />标签上，以渲染一个包含多节点的结构块。如
<block wx:for="{{[1,2,3]}}">
    <view>{{index}}</view>
    <view>{{item}}</view>
</block>


```

- 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态，需要使用wx:key来指定列表中项目的唯一的标识符

- **wx:key的值两种形式**
- 1、字符串，代表在for循环的array中item的某个property，该property的值需要是列表中唯一的字符串或数组，且不能动态改变
- 2、保留关键字this代表在for循环中的item本身，这种表示需要item本身是一个唯一的字符串或者数字。

**wx:key示例WXML**
```HTML

<switch wx:for="{{objectArray}}" wx:key="unique" > {{item.id}} </switch>
<button bindtap="switch"> Switch </button>
<button bindtap="addToFront"> Add to the front </button>


<switch wx:for="{{numberArray}}" wx:key="*this" > {{item}} </switch>
<button bindtap="addNumberToFront"> Add Number to the front </button>
```

**wx:key示例JavaScript**
```JS
Page({
  data: {
    objectArray: [
      {id: 5, unique: 'unique_5'},
      {id: 4, unique: 'unique_4'},
      {id: 3, unique: 'unique_3'},
      {id: 2, unique: 'unique_2'},
      {id: 1, unique: 'unique_1'},
      {id: 0, unique: 'unique_0'},
    ],
    numberArray: [1, 2, 3, 4]
  },
  switch: function(e) {
    const length = this.data.objectArray.length
    for (let i = 0; i < length; ++i) {
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    }
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addToFront: function(e) {
    const length = this.data.objectArray.length
    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)
    this.setData({
      objectArray: this.data.objectArray
    })
  },
  addNumberToFront: function(e){
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData({
      numberArray: this.data.numberArray
    })
  }
})
```
#### 模板

- WXML提供模板 template,可以在模板中定义代码片段，然后在不同的地方调用。使用name属性，作为模板的名字，然后在<template /> 内定义代码片段
```HTML
<template name="msgItem">
    <view>
        <text>{{index}}:{{msg}}</text>
        <text>Time: {{time}}</text>
    </view>
</template>

//使用js属性，声明需要的使用的模板，然后将模板所需要的data传入

<!--
    item:{
        index:0,
        msg:'this is a template',
        time:'2016-06-18
    }
-->

<template is="msgItem" data="{{...item}}" />
<!-- 输出 
    0：this is a template Time:2016-06-18
-->


//JS可以动态决定具体需要渲染哪个模板

<template name="odd">
    <view>odd</view>
</template>

<template name="even">
    <view>even</view>
</template>

<block wx:for="{{[1,2,3,4,5]}}">
    <template is="{{item % 2 === 0 ? 'even' : 'odd'}}" />
</block>

<!-- 输出
    odd
    even
    odd
    even
    odd
-->
```
#### 引用
- WXML提供两种文件引用方式 **import 和 include**
- import 可以在该文件中使用目标文件定义的template,如
```HTML
<!-- item.wxml -->
<template name="item">
    <text>{{text}}</text>
</template>

<!-- 在index.wxml中引用了item.wxml，就可以使用item模板 -->
<import src="item.wxml" />

<template is="item" data = "{{text: 'forbar'}}">

//注意：import是有作用域的，只会import目标文件中定义的template，而不会import目标文件中import的template，简言之就是import不具有递归的特性。
//如，C引用了B，B引用了A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。

```
- include可以将目标文件中除了<template/> <wxs/>外的整个代码引入，相当于是拷贝到include位置。如

```HTML
<!-- index.wxml -->
<include src="header.wxml" />
<view>body</view>
<include src="footer.wxml" />


<!-- header.wxml -->
<view>header</view>

<!-- footer.wxml -->
<view>footer</view>

```



### 二.wxss 后缀的 WXSS 样式文件

- WXSS 具有 CSS 大部分的特性

**WXSS扩展和新增**
- 1、新增尺寸单位rpx。适配不同宽度的屏幕，开发起来更简单。WXSS在底层支持新的尺寸单位px。由于换算采用的是浮点数运算，所以运算结果和预期结果有一点点偏差.
- 在一个宽度为375物理像素的屏幕下，1rpx = 1px
- 2、提供全局样式和局部样式。和app.json，page.json概念相同，可以写一个app.wxss作为全局样式。
- 3、WXSS仅支持部分CSS选择器。
- 在CSS中，可以这样引用另一个样式文件 @import url('./test_0.css')，在小程序中有可以这样引用@import './test_0.wxss'。由于WXSS最终会被编译打包到目标文件中，用户只需要下载一次。

#### 内联样式
- WXSS内联样式与Web开发一致
- 小程序支持动态更新内联样式
```HTML
<!-- index.wxml -->
<!-- 可动态变化的内联样式 -->
<!-- 
    {
        eleColor: 'red',
        eleFontsize:'48rpx'
    }
 -->
<view style="color:{{eleColor}};font-size:{{eleFontsize}}"></view>

```
#### 选择器

- WXSS与CSS类似
    |  名称   | 层级  |
    |  ----  | ----  |
    | !important | ~ | 
    | style="" | 1000 | 
    | #id | 100 | 
    | .class | 10 | 
    | element | 1 | 

#### 官方样式库WeUI

- [参考文档](https://github.com/Tencent/weui-wxss)


### 三.js 后缀的 JS 脚本逻辑文件
- 小程序的主要开发语言是JavaScript，开发者使用JS开开发业务逻辑及调用小程序的API来完成业务需求。
- 一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。如下面的例子：

```HTML
    <view>{{ msg }}</view>
    <button bindtap="clickMe">点击我</button>
```

```js
    Page({
        clickMe:function(){
            this.setData({ msg:"Hello World" })
        }
    })
```
- 更多的相应事件操作，[可参考](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)
  
> 可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。

#### 不同环境下的JavaScript

**浏览器中JavaScript 构成**
- 浏览器中的JavaScript 是由 ECMAScript 和 BOM（浏览器对象模型）以及 DOM（文档对象模型）组成的

**NodeJS中JavaScript 构成**
- NodeJS中的JavaScript 是由 ECMAScript 和 NPM以及Native模块组成

**小程序中的JavaScript 构成**
- 小程序中的 JavaScript 是由ECMAScript 以及小程序框架和小程序 API 来实现的
- 所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。

#### 小程序的执行环境

**小程序目前可以运行的三大平台：**
- iOS平台，包括iOS9、iOS10、iOS11
- Android平台
- 小程序IDE
  
**开发者需要再项目设置中，勾选ES6转ES5的功能。** 设置->项目设置

#### 模块化

- 浏览器中，所有js是运行在同一个作用域下的
- 小程序中，可以将任何一个js文件作为一个模块，通过module.exports或者exports对外暴露接口。

```JS
// moduleA.js
module.exports = function(value){
  return value * 2;
}

//B.js
//在B.js中引用模块A
var multiplyBy2 = require('./moduleA')
var result = multiplyBy2(4)


//在需要使用这些模块的文件中，使用require(path)将公共代码引入
var common = require('common.js')
Page({
  helloMINA:function(){
    common.sayHello('MINA')
  },
  goodbyeMINA:function(){
    common.sayGoodbye('MINA')
  },
})

```
#### 脚本的执行顺序
- 浏览器中，脚本严格按照加载的顺序执行
- 小程序中，执行的入口文件是app.js,并且会根据其中require的模块顺序决定文件的运行顺序。
```JS
//app.json
{
  "pages": [
    "pages/index/index",
    "pages/log/log",
    "pages/result/result"
  ],
  "window": {}
}


//app.js
console.log('app.js')

// pages/index/index
console.log('pages/index/index')

// pages/log/log
console.log('pages/log/log')

// pages/result/result
console.log('pages/result/result')


//以上文件执行后的结果为：
app.js
pages/index/index
pages/log/log
pages/result/result

```

#### 作用域

> 在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会相互影响。
> 当需要使用全局变量时，通过使用全局函数getApp()获取全局的实例，并设置相关属性值，来达到设置全局变量的目的。

```JS
//a.js
//获取全局变量
var global = getApp()
global.globalValue = 'globalValue'


//b.js 中访问a.js定义的全局变量
//访问全局变量
var global = getApp()
console.log(global.globalValue) //输出 globalValue

```
- 注意：上述示例只有在a.js比b.js先执行才有效。
- 当需要保证全局的数据可以在任何文件中安全的被使用到，那么可以在App()中进行设置。


## 小程序宿主环境

- 微信客户端给小程序缩提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。
  
### 1、渲染层和逻辑层
- 小程序的运行环境分为渲染层和逻辑层，其中WXML模板和WXSS样式工作在渲染层，JS脚本工作在逻辑层。
- 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。
<img src="https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png" />

```JS
//渲染层和数据相关
<view>{{ msg }}</view>

//逻辑层负责产生、处理数据
//逻辑层通过Page实例的 setData 方法传递数据到渲染层
Page({
  onLoad:function(){
    this.setData({ msg:'Hello World' })
  }
})

```
#### 数据驱动

- 什么是数据驱动？
> 在开发UI界面过程中，程序需要维护很多变量状态，同时要操作对应的UI元素，随着界面越来越复杂，我们需要维护很多变量状态，同时要处理很多界面上的交互事件，整个程序变得越来越复杂。通常界面视图和变量状态是相关联的，如果有某种‘方法’可以让状态和视图绑定在一起（状态变更时，视图也能自动变更），那我们就可以省去手动修改视图的工作。
- 数据驱动原理
> WXML可以先转成JS对象，然后再渲染出真正的DOM树。
> 通过setData修改数据，产生的js对象的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的DOM树上，从而达到更新UI的目的，这就是“数据驱动”的原理。


### 2、程序与页面
#### 程序
- 一个小程序是由多个“页面”组成的“程序”。“小程序”指的是产品层面的程序，而“程序”指的是代码层面的程序实例。
- App()构造器必须写在项目根目录的app.js里，App是单例对象，在其他JS脚本中可以使用宿主环境提供的getApp（）来获取程序实例。
- 微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。
- 紧接着通过app.json的pages字段就可以知道你当前小程序的所有页面路径
```JS
{
    "pages":[
        "pages/index/index",
        "pages/logs/logs"
    ]
    //在pages字段的第一个页面就是这个小程序的首页
}
```
- 小程序启动后，在app.js定义的App实例的 onLaunch 回调会被执行
```JS   
//App构造器接受一个Object参数。
//onLaunch/onShow/onHide 三个回调是App实例的生命周期函数
//onError
App({
    onLaunch:function(){
        //小程序启动之后 触发
    }
})
```
- 整个小程序只有一个App实例，是全部页面共享的。

    **App构造器的参数**
    |  名称   | 类型  | 描述  |
    |  ----  | ----  | ----  |
    | onLaunch | Function |  当小程序初始化完成时，会触发onLaunch（全局只触发一次） | 
    | onShow | Function |  当小程序启动时，或从后台进入前台显示，会触发onShow | 
    | onHide | Function |  当小程序从前台进入后台，会触发onHide | 
    | onError | Function |  当小程序发生脚本错误，或者API调用失败时，会触发onError并带上错误信息 | 
    |  其他字段 | 任意 |  可以添加任意的函数或数据到Object参数中，在App实例回调用this可以访问 | 

**程序的生命周期和打开场景**
> 初次进入小程序，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境，初始化完毕后，微信客户端就会给App实例派发onLaunch事件，App构造器参数所定义的onLaunch方法会被调用

> 进入小程序 后，用户可以点击右上角的关闭，或者按手机设备的Home键离开小程序，此时小程序并没有被直接销毁，我们把这种情况称为“小程序进入后台状态”,App构造器参数所定义的onHide方法会被调用。

> 当再次回到微信或者再次打开小程序时，微信客户端会把’后台‘的小程序唤醒，这种情况称为“小程序进入前台状态“,App构造器参数所定义的onShow方法会被调用。

>App的生命周期是由微信客户端根据用户操作主动触发的。

- [获取最新的场景值说明请查看官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html)

**微信端打开小程序的途径**
- 群聊会话打开
- 小程序列表中打开
- 微信扫一扫
- 从另外一个小程序打开当前小程序等

  
**小程序页面怎么写**
- 如pages/logs/logs 下面包括了4种文件，微信客户端会先根据logs.json配置生成一个界面，顶部的颜色和文字你都可以再这个json文件里面定义好。紧接着客户端就会装载这个页面的WXML结构和WXSS样式。最后客户端会装载logs.js，可以看到logs.js的大体内容就是：
```JS
Page({
    data:{ //参与页面渲染的数据
        logs:[]
    },
    onLoad: function(){
        //页面渲染后，执行
    }
})
```
- Page是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把data数据和index.wxml一起渲染出最终的结构。
- 在渲染完界面之后，页面实例就会收到一个 onLoad的回调，你可以再这个回调处理你的逻辑。


#### 页面




## 小程序场景应用

## 小程序协同工作和发布


## 小程序底层框架



## 小程序性能优化

## 小程序基础库的更新迭代

## 微信开发者工具